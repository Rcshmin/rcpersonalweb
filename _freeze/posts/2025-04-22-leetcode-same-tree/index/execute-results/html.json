{
  "hash": "e982b2eae7bbefb47433d387715d80b0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Same tree?\"\ndescription: \"My solution to leetcode problem 100\"\nauthor:\n  - name: Rashmin Chitale\n    url: \ndate: 04-22-2025\ncategories: [leetcode,R] # self-defined categories\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n\n\n\n# The background\n\n::: callout-note\n## When are two trees the same?\n\nTwo trees are the same when they share exactly the `same structure`. This includes everything from the depth, the positions of the nodes, and the values of the nodes themselves.\n:::\n\nA simple example where 2 trees are exactly the same is when\n\n::::{layout-ncol=2}\n\n:::{}\n\n\n```{mermaid}\ngraph TD\n  A((01)) --> B((02))\n  A((01)) --> C((03))\n  B((02)) --> D((04))\n  B((02)) --> E((05))\n  C((03)) --> F((06))\n  C((03)) --> G((07))\n  \n```\n\n\n:::\n\n:::{}\n\n\n```{mermaid}\ngraph TD\n  A((01)) --> B((02))\n  A((01)) --> C((03))\n  B((02)) --> D((04))\n  B((02)) --> E((05))\n  C((03)) --> F((06))\n  C((03)) --> G((07))\n  \n```\n\n\n:::\n::::\n\nversus an example when 2 trees are not the same is\n\n::::{layout-ncol=2}\n\n:::{}\n\n\n```{mermaid}\ngraph TD\n  A((01)) --> B((02))\n  A((01)) --> C((03))\n  B((02)) --> D((04))\n  B((02)) --> E((05))\n```\n\n\n:::\n\n:::{}\n\n\n```{mermaid}\ngraph TD\n  A((01)) --> B((02))\n  A((01)) --> C((03))\n  C((03)) --> D((04))\n  C((03)) --> E((05))\n\n  \n```\n\n\n:::\n::::\n\nClearly, visually it is quite simple to observe whether a tree is the same or not, but how can this be coded.\n\n# The solution\n\nIn my solution, I will carry over some of the code from my other [post](../2025-01-16-leetcode-max-depth-tree/index.qmd). I first define a node as follows \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNode = R6Class(\n  classname = \"Node\", \n  public = list(\n    left = NA,\n    right = NA,\n    value = \"numeric\",\n    initialize =\n      function(left = NA, right = NA, value = NA){\n        self$left = left\n        self$right = right\n        self$value = value\n      }\n  )\n)\n```\n:::\n\n\n\nThe main algorithm is then as follows\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTree = R6Class(\n  classname = \"Tree\",\n  public = list(\n    initialize = function(){},\n    same.tree = \n      function(tree1, tree2){\n        \n        #check for nullity of children nodes for both trees\n        left.na1 = !is.environment(tree1$left) & is.environment(tree1$right)\n        right.na1 = is.environment(tree1$left) & !is.environment(tree1$right)\n        both.na1 = !is.environment(tree1$left) & !is.environment(tree1$right)\n        left.na2 = !is.environment(tree2$left) & is.environment(tree2$right)\n        right.na2 = is.environment(tree2$left) & !is.environment(tree2$right)\n        both.na2 = !is.environment(tree2$left) & !is.environment(tree2$right)\n        \n        #are these conditions the same across both trees\n        left.eq = left.na1 == left.na2\n        right.eq = right.na1 == right.na2\n        both.eq = both.na1 == both.na2\n        all.eq = all(left.eq, right.eq, both.eq)\n        \n        if(tree1$value == tree2$value & all.eq == TRUE){\n          #choose what type of recursion to carry out\n          if(left.na1 == TRUE){\n            self$same.tree(tree1$right, tree2$right)\n          } else if(right.na1 == TRUE){\n            self$same.tree(tree1$left, tree2$left)\n          } else if (both.na1 == TRUE){\n            #no children for both trees at current node, and value are same so...\n            return(TRUE)\n          } else {\n            self$same.tree(tree1$left, tree2$left)\n            self$same.tree(tree1$right, tree2$right)\n          }\n        } else {\n          #trees are not the same\n          return(FALSE)\n        }\n      }\n  ))\n```\n:::\n\n\n\nThe logic behind checking whether two trees are the same as follows\n\n1. Starting at the root node of both trees, we check the nullity of the children node of the root node for both trees. That is, if they exist and the structure (left, right or both)\n2. If this structure is the same across both trees, AND the value of the root nodes is the same as well, we assume the tree is the same thus far at the current level. If not, then the trees are different.\n3. We then recursively descend down into the children node (if they exist, if they do not the trees are the same since it passed the previous checks) of both trees and repeat the above checks.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##### Test case 1... #####\n\ntree1 = Node$new(value = 1)\ntree2 = Node$new(value = 1)\n\nTree$new()$same.tree(tree1,tree2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n##### Test case 2... #####\n\ntree3 = Node$new(value = 1)\ntree3[[\"left\"]] = Node$new(value = 2)\ntree3[[\"right\"]] = Node$new(value = 3)\n\nTree$new()$same.tree(tree1,tree3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n##### Test case 3... #####\n\ntree4 = Node$new(value = 1)\ntree4[[\"left\"]] = Node$new(value = 2)\ntree4[[\"left\"]][[\"left\"]] = Node$new(value = 3) \ntree4[[\"left\"]][[\"left\"]][[\"left\"]] = Node$new(value = 4) \ntree4[[\"left\"]][[\"left\"]][[\"left\"]][[\"left\"]] = Node$new(value = 5) \n\nTree$new()$same.tree(tree3,tree4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n##### Test case 4... #####\n\ntree5 = Node$new(value = 5)\ntree5[[\"left\"]] = Node$new(value = 4)\ntree5[[\"left\"]][[\"left\"]] = Node$new(value = 3) \ntree5[[\"left\"]][[\"left\"]][[\"left\"]] = Node$new(value = 2) \ntree5[[\"left\"]][[\"left\"]][[\"left\"]][[\"left\"]] = Node$new(value = 1) \n\nTree$new()$same.tree(tree4,tree5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n##### Test case 5... #####\n\ntree6 = Node$new(value = 1000)\ntree6[[\"left\"]] = Node$new(value = 9999)\ntree6[[\"left\"]][[\"right\"]] = Node$new(value = 991239)\ntree6[[\"left\"]][[\"right\"]][[\"left\"]] = Node$new(value = 19)\n                          \ntree7 = Node$new(value = 1000)\ntree7[[\"left\"]] = Node$new(value = 9999)\ntree7[[\"left\"]][[\"right\"]] = Node$new(value = 991239)\ntree7[[\"left\"]][[\"right\"]][[\"left\"]] = Node$new(value = 19)\n                           \nTree$new()$same.tree(tree6,tree7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}