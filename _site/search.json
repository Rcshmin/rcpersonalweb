[
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "My Blog",
    "section": "",
    "text": "k-NN from scratch\n\n\n\ndatascience\n\n\nR\n\n\n\nA from scratch implementation of the k-nearest-neighbors algorithm in R\n\n\n\nRashmin Chitale\n\n\nOct 24, 2022\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "rcpersonalweb",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/2024-11-26-k-nearest-neighbors/index.html",
    "href": "posts/2024-11-26-k-nearest-neighbors/index.html",
    "title": "k-NN from scratch",
    "section": "",
    "text": "The k-nearest neighbors algorithm (k-NN) is a non-parametric supervised learning method. Non-parametric meaning the algorithm does not make any distributional assumptions about the data, and supervised meaning data with labels is used.\n\n“The k-nearest neighbors algorithm (k-NN) was first developed by Evelyn Fix and Joseph Hodges in 1951, and later expanded by Thomas Cover. It is used for classification and regression. In both cases, the input consists of the k closest training examples in a data set. In k-NN classification, the output is a class membership. An object is classified by a plurality vote of its neighbors, with the object being assigned to the class most common among its k nearest neighbors (k is a positive integer, typically small). If k = 1, then the object is simply assigned to the class of that single nearest neighbor.In k-NN regression, the output is the property value for the object. This value is the average of the values of k nearest neighbors - Wikipedia”\n\nIn simple terms, the algorithm is passed a data set with labels, and a new point which is not in the provided data. The algorithm uses the proximity of other points from the data set near the new data point to make predictions about the individual point. This prediction can either be a classification, or a numeric value. Pictures always help, so lets take a look at one!\n\n\n\n\n\n\n\n\n\n\n\nIn the beside image we have two features, namely \\(X_{1}\\) and \\(X_{2}\\). We also have two classes, A and B, which are respectively denoted by yellow and purple points. Our new point which is to be classified or regressed on is red. You might already be guessing how some of the terms such as ‘proximity’ and ‘plurality vote’ factor into this algorithm from the image, but I will spell it out for you JIC. So to assign the red point a class we look at its \\(k\\) nearest neighbors. The word neighbor implies nearness. So we look at the points that are closest to the red point. For \\(k=1\\), this is the single closes point, for \\(k=2\\) this is the two closest points, for \\(k=3\\) this is the three closest points and so on. Now, consider the \\(k=3\\) case show in the image. Of the three closest points to the red point, two are purple and one is yellow. If a ‘plurality vote’ was two occur, one yellow point would vote that the red point should be assigned to class A, whereas two purple points would vote that it should be class B. Clearly, the purple points win, so the red point would be assigned to class B. But this will not always be the case. With \\(k=6\\) it is direct that yellow points outnumber the purple, and hence the ‘vote’ is won by the yellow points; the red point will be assigned to class A.\n\n\n\nThere is always the chance that there will be an equal amount of the ‘highest vote number’ for some \\(k\\). This means when the vote occurred, there was an equal amount of points belonging to two or more different classes (tied values). There are multiple ways to eliminate this tie.\n\nChoose a different \\(k\\): A tie will likely not exist for all potential values of \\(k\\). So we can change our \\(k\\). Simple enough. But arbitrarily choosing any other \\(k\\) does not ensure that there will be no ties\nRandomly choose between the tied values: Just as the name suggests\nAllow in until natural stop: This one is a little more nuanced than the others. Choose the smallest number \\(k\\) where \\(k \\geq 2\\) such that there exists no ties"
  },
  {
    "objectID": "posts/2024-11-26-k-nearest-neighbors/index.html#visual-example",
    "href": "posts/2024-11-26-k-nearest-neighbors/index.html#visual-example",
    "title": "k-NN from scratch",
    "section": "",
    "text": "In the beside image we have two features, namely \\(X_{1}\\) and \\(X_{2}\\). We also have two classes, A and B, which are respectively denoted by yellow and purple points. Our new point which is to be classified or regressed on is red. You might already be guessing how some of the terms such as ‘proximity’ and ‘plurality vote’ factor into this algorithm from the image, but I will spell it out for you JIC. So to assign the red point a class we look at its \\(k\\) nearest neighbors. The word neighbor implies nearness. So we look at the points that are closest to the red point. For \\(k=1\\), this is the single closes point, for \\(k=2\\) this is the two closest points, for \\(k=3\\) this is the three closest points and so on. Now, consider the \\(k=3\\) case show in the image. Of the three closest points to the red point, two are purple and one is yellow. If a ‘plurality vote’ was two occur, one yellow point would vote that the red point should be assigned to class A, whereas two purple points would vote that it should be class B. Clearly, the purple points win, so the red point would be assigned to class B. But this will not always be the case. With \\(k=6\\) it is direct that yellow points outnumber the purple, and hence the ‘vote’ is won by the yellow points; the red point will be assigned to class A."
  },
  {
    "objectID": "posts/2024-11-26-k-nearest-neighbors/index.html#an-interesting-case",
    "href": "posts/2024-11-26-k-nearest-neighbors/index.html#an-interesting-case",
    "title": "k-NN from scratch",
    "section": "",
    "text": "There is always the chance that there will be an equal amount of the ‘highest vote number’ for some \\(k\\). This means when the vote occurred, there was an equal amount of points belonging to two or more different classes (tied values). There are multiple ways to eliminate this tie.\n\nChoose a different \\(k\\): A tie will likely not exist for all potential values of \\(k\\). So we can change our \\(k\\). Simple enough. But arbitrarily choosing any other \\(k\\) does not ensure that there will be no ties\nRandomly choose between the tied values: Just as the name suggests\nAllow in until natural stop: This one is a little more nuanced than the others. Choose the smallest number \\(k\\) where \\(k \\geq 2\\) such that there exists no ties"
  },
  {
    "objectID": "posts/2024-11-26-k-nearest-neighbors/index.html#euclidean-distance",
    "href": "posts/2024-11-26-k-nearest-neighbors/index.html#euclidean-distance",
    "title": "k-NN from scratch",
    "section": "Euclidean distance",
    "text": "Euclidean distance\nEuclidean distance is a perhaps the most common and well known measure of distance in mathematics. As I recall from my golden high school days, it is used just about everywhere; complex numbers, vectors, trigonometry, calculus and so on.\n\n“In mathematics, the Euclidean distance between two points in Euclidean space is the length of a line segment between the two points. It can be calculated from the Cartesian coordinates of the points using the Pythagorean theorem, therefore occasionally being called the Pythagorean distance.”\n\n\n\n\n\n\n\n\n\n\nIn two-dimensions the Euclidean distance is simple enough. It follows directly from Pythagoras theorem, and is nothing more than the sum of the squared differences of the \\(x\\) and \\(y\\) coordinates. Suppose we have two points in the Cartesian space \\(p = (p_{1}, p_{2})\\) and \\(q = (q_{1}, q_{2})\\). Then the Euclidean distance is\n\\[\\begin{align*}\n\nd(p,q) = \\sqrt{(q_{1}-p_{1})^2 +(q_{2}-p_{2})^2}\n\n\\end{align*}\\]\nSome fancy geometric proofs, and pattern observing lands us the \\(n\\) dimensional Euclidean distance, which is not too different from the two dimensional one. Suppose we have two points in a \\(n\\) dimensional space, \\(p = (p_{1}, p_{2}, ... , p_{n})\\) and \\(q = (q_{1}, q_{2}, ... , q_{n})\\) . Then the Euclidean distance is \\[\\begin{align*}\n\nd(p,q) = \\sqrt{(q_{1}-p_{1})^2 + (q_{2}-p_{2})^2 + (q_{3}-p_{3})^2 + ... + (q_{n}-p_{n})^2}\n\n\\end{align*}\\]\nThis is the metric I will use to establish ‘proximity’ later due to its simplicity, and appropriateness for the latter notion. But it is important to note that the Euclidean distance does not perform as well in very high dimensions numbers. Enter, the curse of dimensionality!.\n\n“The curse of dimensionality refers to various phenomena that arise when analyzing and organizing data in high-dimensional spaces that do not occur in low-dimensional settings such as the three-dimensional physical space of everyday experience. The curse of dimensionality in the k-NN context basically means that Euclidean distance is unhelpful in high dimensions because all vectors are almost equidistant to the search query vector”\n\nJust to spice things up, I will throw another distance metric into the bag, but lets first encode the euclidean distance metric\n\nget_euclid &lt;- function(p, q){\n  #Check for same length\n  if(length(p) != length(q)) return(\"Error, unequal length!\")\n  #Calculate distance\n  distance = sqrt(sum((q-p)^2))\n  return(distance)\n}"
  },
  {
    "objectID": "posts/2024-11-26-k-nearest-neighbors/index.html#cosine-distance",
    "href": "posts/2024-11-26-k-nearest-neighbors/index.html#cosine-distance",
    "title": "k-NN from scratch",
    "section": "Cosine distance",
    "text": "Cosine distance\n\nCosine similarity/distance measures the similarity between two vectors of an inner product space. Mathematically, it measures the cosine of the angle between two vectors projected in a multi-dimensional space. Using this distance we get values between 0 and 1, where 0 means the vectors are 100% similar to each other and 1 means they are not similar at all\n\nCosine distance has the below formula\n\\[\\begin{align*}\n\n\\cos{\\theta} = \\frac{\\overrightarrow{a}\\cdot\\overrightarrow{b}}{||\\overrightarrow{a}|| \\times ||\\overrightarrow{b}||}\n\n\\end{align*}\\]\nThose of you familiar with vectors and linear algebra will note that cosine similarity is just a re-arrangement of the dot product formula. The closer the cosine value is to 1, the smaller the angle between the two vectors, and the greater the match between the two vectors. And vice versa. Earlier I mentioned that euclidean distance breaks down in higher dimensions. Since cosine distance looks how closely two points are oriented to each other, it deals with data with a large number of dimensions better (i.e. when the data is sparse)\n\nget_cosine &lt;- function(p, q){\n  #Check for same length\n  if(length(p) != length(q)) return(\"Error, unequal length!\")\n  #Calculate cosine distance\n  cos_dot = sum(p*q)\n  p_mag = sqrt(sum(p^2))\n  q_mag = sqrt(sum(q^2))\n  cos_dis = 1 - cos_dot/(p_mag*q_mag)\n  return(round(cos_dis, digits = 10))\n}"
  },
  {
    "objectID": "posts/2024-11-26-k-nearest-neighbors/index.html#classification",
    "href": "posts/2024-11-26-k-nearest-neighbors/index.html#classification",
    "title": "k-NN from scratch",
    "section": "Classification",
    "text": "Classification\nThe kNN algorithm for classification calculates the distance between the new point and all the other points in the data set. It sorts the distances from the shortest to furthest and then chooses the \\(k\\) smallest distances. The get_majority_vote() helper is called on the labels of theses \\(k\\) smallest distances to produce the dominant label which is then returned by the function. As it turns out the regression problem is even easier than that of classification. A majority vote helper is not even required. We simply find the \\(k\\) nearest neighbors, and average the value of the target variable to find the value for the new point.\n\nknn_classify &lt;- function(df, k, new_point, type){\n  #Check the new point is of same length\n  if(length(new_point) != ncol(df) - 1) return(\"Error, unequal length!\")\n  #Calculate the distances and order them\n  df_euclid = df[, (ncol(df) - 1):ncol(df)] \n  df_points = as.data.frame(df[, 1:(ncol(df)-1)])\n  for(i in 1:nrow(df_euclid)){\n    df_euclid[i, 1] = get_euclid(p = new_point, \n                                 q = as.numeric(df_points[i, ]))\n  }\n  df_order = df_euclid[order(df_euclid[,1]), ]\n  #Return the k-closest neighbors\n  df_knn = df_order[1:k, ]\n  labels_k = df_knn[, 2]\n  #The dominating label\n  dom_label = get_majority_vote(labels = labels_k)\n  return(dom_label)\n}"
  },
  {
    "objectID": "posts/2024-11-26-k-nearest-neighbors/index.html#regression",
    "href": "posts/2024-11-26-k-nearest-neighbors/index.html#regression",
    "title": "k-NN from scratch",
    "section": "Regression",
    "text": "Regression\nAs it turns out the regression problem is even easier than that of classification. A majority vote helper is not even required. We simply find the \\(k\\) nearest neighbors, and average the value of the target variable to find the value for the new point.\n\nknn_regress &lt;- function(df, k, new_point){\n  #Check the new point is of same length\n  if(length(new_point) != ncol(df) - 1) return(\"Error, unequal length!\")\n  #Calculate the distances and order them\n  df_euclid = df[, (ncol(df) - 1):ncol(df)] \n  df_points = as.data.frame(df[, 1:(ncol(df)-1)])\n  for(i in 1:nrow(df_euclid)){\n    df_euclid[i, 1] = get_euclid(p = new_point, \n                                 q = as.numeric(df_points[i, ]))\n  }\n  df_order = df_euclid[order(df_euclid[,1]), ]\n  #Return the k-closest neighbors\n  df_knn = df_order[1:k, ]\n  #The average value\n  regress_val = mean(df_knn[, 2])\n  return(regress_val)\n}\n\nknn_regress(df = iris[,1:3], k = 1, new_point = c(7, 4))\n\n[1] 6.1"
  },
  {
    "objectID": "posts/2024-11-26-k-nearest-neighbors/index.html#classification-performance",
    "href": "posts/2024-11-26-k-nearest-neighbors/index.html#classification-performance",
    "title": "k-NN from scratch",
    "section": "Classification performance",
    "text": "Classification performance\n\nModel validation\nOne way we can evaluate the classifier is by splitting the iris data into a training and testing set. The training set will consist of points that will be used the “new points” in the testing set. We can then compare the classifications outputted by using the algorithm on the testing set versus what the classifications actually are.\n\n#Train test split\nset.seed(21312)\ndt = sort(sample(nrow(iris), nrow(iris)*.7))\ntrainData &lt;- iris[dt,]\ntestData &lt;- iris[-dt,]\n\n#Accuracy of k for dif vals on one possible split\naccuracy = c()\nfor(j in 1:20){\nfor(i in 1:nrow(testData)){\ntestData[i, 6] = knn_classify(df = trainData, k = j, new_point = c(as.numeric(testData[i, 1:4])))\nif(testData[i, 6] == testData[i, 5]){\n  testData[i, 7] = TRUE\n} else {\n  testData[i, 7] = FALSE\n}}\naccuracy[j] = length(which(testData[, 7] == TRUE))/nrow(testData)\n}\naccuracy\n\n [1] 0.9333333 0.9333333 0.9555556 0.9555556 1.0000000 1.0000000 1.0000000\n [8] 1.0000000 0.9777778 0.9777778 0.9333333 0.9333333 0.9555556 0.9555556\n[15] 0.9333333 0.9333333 0.9555556 0.9555556 0.9333333 0.9333333\n\n#Confusion matrix for k = 5\nfor(i in 1:nrow(testData)){\ntestData[i, 6] = \n  knn_classify(df = trainData, k = 20, \n               new_point = c(as.numeric(testData[i, 1:4])))\nif(testData[i, 6] == testData[i, 5]){\n  testData[i, 7] = TRUE\n} else {\n  testData[i, 7] = FALSE\n}}\ntable(testData$Species, testData$V6) \n\n            \n             setosa versicolor virginica\n  setosa         13          0         0\n  versicolor      0         14         1\n  virginica       0          2        15\n\n\nFor \\(k=20\\) the confusion matrix (mis-classifcation matrix), shows that the model performs quite well. Two virginica species were incorrectly classified as versicolor. One versicolor species was incorrectly classified as virginica. Else all seems well. It is also clear that for many different values of \\(k\\), the model has 100% accuracy. This means that it can correctly classify samples from the training data set by considering the proximity to points in the train data set. A 100% accuracy is not always good. It may indicate that the k-NN model is over fitted to the data, and will not generalise to new data points. This is closely related to the notion of the bias-variance tradeoff. I will not delve into the specifics for now, as this concept deserves its own explanation.\nBack to the problem at hand. Earlier we saw that there were many values of \\(k\\) which produced an accuracy of 100% on one particular train test split. However if we shuffled the data, or changed the train test split ratio, the model would perform differently for the same value of \\(k\\). Surely, there is a way to find out which \\(k\\) performs the best on average across different train test splits for our data? Enter k-fold cross validation.\n\n#Perform 10 fold cross validation\nk = 10\nz = 40\nset.seed(23131)\nk_fold_data = mutate(iris, my.folds = sample(1:k, size = nrow(iris), replace = TRUE))\ntable(k_fold_data$my.folds)\n\n\n 1  2  3  4  5  6  7  8  9 10 \n15 19 17 17 12 17 14 14 12 13 \n\n#a = z is no of neighbors, b is which partition to use as test\nk_fold_accuracy = vector(\"list\", z)\nfor(a in 1:z){\n  for(b in 1:k){\n    #Split into train and test based off which partition to use\n    k_fold_test = k_fold_data[k_fold_data$my.folds == b, ]\n    k_fold_train = k_fold_data[k_fold_data$my.folds != b, 1:5]\n    \n    #For given a,b check if predicted matches true label\n    for(i in 1:nrow(k_fold_test)){\n      k_fold_test[i, 7] = \n        knn_classify(df = k_fold_train, \n                     k = a, \n                     new_point = c(as.numeric(k_fold_test[i, 1:4])))\n     if(k_fold_test[i, 5] == k_fold_test[i, 7]){\n       k_fold_test[i, 8] = TRUE\n     } else {\n        k_fold_test[i, 8] = FALSE\n      }\n    }\n    \n    #Fill list with accuracy\n    k_fold_accuracy[[a]][b] =\n      length(which(k_fold_test[, 8] == TRUE))/nrow(k_fold_test)\n    next(b)\n  }\n  next(a)\n}\n\n#Weights of each partition, then multiply to get average\nk_fold_weights = as.numeric(table(k_fold_data$my.folds)/nrow(k_fold_data))\nfor(i in 1:length(k_fold_accuracy)){\n  k_fold_accuracy[[i]] = sum(k_fold_accuracy[[i]]*k_fold_weights)\n}\n\nas.numeric(k_fold_accuracy)\n\n [1] 0.9600000 0.9600000 0.9666667 0.9666667 0.9600000 0.9600000 0.9666667\n [8] 0.9666667 0.9600000 0.9600000 0.9666667 0.9666667 0.9800000 0.9800000\n[15] 0.9800000 0.9800000 0.9800000 0.9800000 0.9666667 0.9666667 0.9800000\n[22] 0.9800000 0.9733333 0.9733333 0.9733333 0.9733333 0.9600000 0.9600000\n[29] 0.9533333 0.9533333 0.9533333 0.9533333 0.9600000 0.9600000 0.9666667\n[36] 0.9666667 0.9600000 0.9600000 0.9533333 0.9533333\n\n\nAverage model performance never reaches 100% accuracy for any \\(k\\). As can seen above the highest average accuracy attained by the model is 98%, which occurs for several different \\(k\\) values. Overall, if we said that all \\(k\\)’s of a reasonably small magnitude perform similarly, we would not be wrong.\n\n#Format data for error\nk_fold_plot = as.data.frame(t(as.data.frame(k_fold_accuracy)))\nrow.names(k_fold_plot) = 1:nrow(k_fold_plot)\nk_fold_plot$k = 1:nrow(k_fold_plot)\ncolnames(k_fold_plot) = c(\"Error (%)\", \"k\")\nk_fold_plot$Error = (1 - k_fold_plot$Error)*100 \n\n#Create line plot\nggplot(data = k_fold_plot, aes(x = k, y = Error)) +\n  geom_line(color = \"orange\", size = 1.5) +\n    theme_classic() +\n  labs(title = \"Cross validated error rate by differing k's\", \n       subtitle = \"Which k performs the best on average?\") +\n    theme(text=element_text(family=\"montsr\"), \n        plot.title = element_text(size=32),\n        plot.subtitle = element_text(size=22),\n        axis.title = element_text(size=22),\n        axis.text = element_text(size=16),\n        legend.text = element_text(size=16), \n        legend.title = element_text(size=22)) +\n  scale_color_pilot()\n\n\n\n\n\n\n\n\n\n\nReason for good performance\nPerhaps, the reason why \\(k\\) does not appear to significantly affect model performance lies in the structure of the iris data set.\n\n#Pair-wise plot\nggpairs(data = iris, columns = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"),\n  lower = list(continuous = \"points\", mapping = aes(color = Species)), \n  upper = list(continuous = \"points\", mapping = aes(color = Species)), \n  diag = list(continuous = \"barDiag\", mapping = aes(color = Species)))\n\n\n\n\n\n\n\n\nOn every pairwise combination of the data, there appears to be significant grouping of the different classes. This shows that the iris data is well suited to the k-NN algorithm. Given that the grouping is quite significant, this confirms the relative indifference of the accuracy of the algorithm to different values of \\(k\\). However, the above plot is only a visualization of pairwise combinations in two dimensions. It would be nice if there were a way to visualize the grouping of classes for all four features of the data.\n\n#Format data for plot\niris_id = iris\niris_id[, 6] = 1:nrow(iris)\niris_parallel_plot = iris_id %&gt;%  \n  pivot_longer(cols = c(\"Sepal.Length\", \"Sepal.Width\", \n                        \"Petal.Length\", \"Petal.Width\"), \n              names_to = \"Feature\", values_to = \"Feature.Value\")\n\n#Make plot\nggplot(data = iris_parallel_plot, aes(x = Feature, y = Feature.Value, color = Species, group = V6)) +\n  geom_point() + \n  geom_line() + \n  scale_x_discrete(limits = c(\"Sepal.Length\", \n                              \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\")) +\n  theme_classic() +\n  labs(title = \"Parallel lines plot of iris\", \n       subtitle = \"Is iris well suited for the k-NN classification\n       algorithm?\") +\n    theme(text=element_text(family=\"montsr\"), \n        plot.title = element_text(size=32),\n        plot.subtitle = element_text(size=22),\n        axis.title = element_text(size=22),\n        axis.text = element_text(size=16),\n        legend.text = element_text(size=16), \n        legend.title = element_text(size=22)) +\n  scale_color_pilot()\n\n\n\n\n\n\n\n\nThe above is a visualization of the multivariate data, known as a parallel lines plot. Since we are searching for a reason for good model performance with the k-NN algorithm, we are looking for grouping in the plot. What I mean by grouping, is that different observations (rows) on iris for a given species follow a similar trajectory across all features; i.e. they are nearby to each other. Given grouping holds relatively well, one thing in addition to consider is distinctness of the trajectories for each species. In the above plot, the setosa species has distinct shape. Versicolor and virginica are similar. This could also be seen earlier in the pair plots.\n\nIn data visualization, an Andrews plot or Andrews curve is a way to visualize structure in high-dimensional data. It is basically a rolled-down, non-integer version of the Kent–Kiviat radar m chart, or a smoothed version of a parallel coordinate plot. It is named after the statistician David F. Andrews.A value \\(x\\) is a high-dimensional datapoint if it is an element of \\(\\mathbb{R}^{d}\\). We can represent high-dimensional data with a number for each of their dimensions, \\(x=\\{x_{1},x_{2},\\ldots ,x_{d}\\}\\). To visualize them, the Andrews plot defines a finite Fourier series:\\(f_{x}(t)={\\frac {x_{1}}{\\sqrt{2}}}+x_{2}\\sin(t)+x_{3}\\cos(t)+x_{4}\\sin(2t)+x_{5}\\cos(2t)+\\cdots\\)\n\n\n\n\n\n\n\n\n\n\nThe Andrews Curves for iris are the smoothed out versions of the parallel lines plot. For iris, they confirm what we saw earlier regarding the grouping of classes."
  },
  {
    "objectID": "posts/2024-11-26-k-nearest-neighbors/index.html#regression-performance",
    "href": "posts/2024-11-26-k-nearest-neighbors/index.html#regression-performance",
    "title": "k-NN from scratch",
    "section": "Regression performance",
    "text": "Regression performance\nOur discussion of the performance of k-NN in regression for different values of \\(k\\), will center around the calculation of the cross validated mean squared error (MSE).\n\nThe mean squared error (MSE) of an estiamtor measures the average square of the errors; the average squared difference between the stimated values and the actual value. It is strictly positive, and represents the quality of an estimator. MSE decreases as the error approaches zero\n\nMSE has the following formula; \\(n\\) is the number of observations, \\(Y_{i}\\) is the \\(i\\)th observed value of the variable, \\(\\hat{Y}_{i}\\) is the \\(i\\)th predicted value of the variable\n\\[\\begin{align*}\n\n\\text{MSE} = \\frac{1}{n} \\sum_{i=1}^{n}{(Y_{i} - \\hat{Y_{i}})^2}\n\n\\end{align*}\\]\nIn addition to this, I will also calculate mean absolute percentage error (MAPE) and mean absolute error (MAE). MAE gives how far on average, each predicted value is from the true value in distance. MAPE is the same as MAE but a percentage\n\\[\\begin{align*}\n\n\\text{MAE} = \\frac{1}{n} \\sum_{i=1}^{n}{|Y_{i} - \\hat{Y_{i}}|}\n\n\\end{align*}\\] \\[\\begin{align*}\n\n\\text{MAPE} = \\frac{1}{n} \\sum_{i=1}^{n}{\\frac{|Y_{i} - \\hat{Y_{i}}|}{Y_{i}}}\n\n\\end{align*}\\]\nTo calculate regression performance, I will use the first three variables of the iris data to estimate the fourth variable\n\n#Perform 10 fold cross validation\nk = 10\nz = 40\nset.seed(23321)\nk_fold_data = mutate(iris, my.folds = sample(1:k, size = nrow(iris), \n                                             replace = TRUE))\ntable(k_fold_data$my.folds)\n\n\n 1  2  3  4  5  6  7  8  9 10 \n17 12 16 14 10 16 14 15 21 15 \n\n#a = z is no of neighbors, b is which partition to use as test\nk_fold_accuracy = vector(\"list\", z)\nk_fold_accuracy1 = vector(\"list\", z)\nk_fold_accuracy2 = vector(\"list\", z)\nfor(a in 1:z){\n  for(b in 1:k){\n    #Split into train and test based off which partition to use\n    k_fold_test = k_fold_data[k_fold_data$my.folds == b, 1:4]\n    k_fold_train = k_fold_data[k_fold_data$my.folds != b, 1:4]\n    \n    #For given a,b check if predicted matches true label\n    for(i in 1:nrow(k_fold_test)){\n      k_fold_test[i, 5] = \n        knn_regress(df = k_fold_train,\n                      k = a, \n                        new_point = as.numeric(k_fold_test[i, 1:3]))\n      k_fold_test[i, 6] = \n        (k_fold_test[i, 4] - k_fold_test[i, 5])^2\n      k_fold_test[i, 7] = \n        abs(k_fold_test[i, 4] - k_fold_test[i, 5])\n      k_fold_test[i, 8] = \n        abs(k_fold_test[i, 4] - k_fold_test[i, 5])/k_fold_test[i, 4]\n    }\n    #Fill list with accuracy\n    k_fold_accuracy[[a]][b] = (1/nrow(k_fold_test))*sum(k_fold_test[, 6])\n    k_fold_accuracy1[[a]][b] = (1/nrow(k_fold_test))*sum(k_fold_test[, 7])\n    k_fold_accuracy2[[a]][b] = (1/nrow(k_fold_test))*sum(k_fold_test[, 8])\n    next(b)\n  }\n  next(a)\n}\n\n#Weights of each partition, then multiply to get average\nk_fold_weights = as.numeric(table(k_fold_data$my.folds)/nrow(k_fold_data))\nfor(i in 1:length(k_fold_accuracy)){\n  k_fold_accuracy[[i]] = sum(k_fold_accuracy[[i]]*k_fold_weights)\n  k_fold_accuracy1[[i]] = sum(k_fold_accuracy1[[i]]*k_fold_weights)\n  k_fold_accuracy2[[i]] = sum(k_fold_accuracy2[[i]]*k_fold_weights)\n}\n\n#Making three line plots\nk_fold_mse = as.data.frame(t(as.data.frame(k_fold_accuracy)))\nrow.names(k_fold_mse) = 1:nrow(k_fold_mse)\ncolnames(k_fold_mse) = c(\"MSE\")\nk_fold_mse$k = 1:nrow(k_fold_mse)\n\nk_fold_mae = as.data.frame(t(as.data.frame(k_fold_accuracy1)))\nrow.names(k_fold_mae) = 1:nrow(k_fold_mae)\ncolnames(k_fold_mae) = c(\"MAE\")\nk_fold_mae$k = 1:nrow(k_fold_mae)\n\nk_fold_mape = as.data.frame(t(as.data.frame(k_fold_accuracy2)))\nrow.names(k_fold_mape) = 1:nrow(k_fold_mape)\ncolnames(k_fold_mape) = c(\"MAPE\")\nk_fold_mape$k = 1:nrow(k_fold_mape)\nk_fold_mape$MAPE = k_fold_mape$MAPE * 100\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn terms of MSE, it seems that at \\(k=6\\), MSE is the closes to zero. However, in terms of the MAE and MAPE, \\(k=10\\) seems to be the best. This is as for \\(k=10\\) the k-NN regressor is on average 0.14 units away from the true value, or around 19% away. One thing is clear though. The k-NN algorithm performs much better in the classification problem, then regression on the iris data set."
  }
]